rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // Helper function to check if user is in same family
    function isInSameFamily(userId, targetUserId) {
      let userDoc = get(/databases/$(database)/documents/users/$(userId));
      let targetDoc = get(/databases/$(database)/documents/users/$(targetUserId));
      return userDoc.data.family_id != null && 
             userDoc.data.family_id == targetDoc.data.family_id;
    }
    
    // Helper function to check if user's email is verified
    function isEmailVerified(userId) {
      let userDoc = get(/databases/$(database)/documents/users/$(userId));
      return userDoc.data.email_verified == true;
    }
    
    // Verification tokens - allow public read/write for email verification
    match /verification_tokens/{tokenId} {
      allow read, write: if true; // Public access for email verification
    }
    
    // Users collection - allow own access and email verification
    match /users/{userId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
      allow create: if request.auth != null && request.auth.uid == userId;
      // Allow email verification updates from any authenticated user (for email verification process)
      allow update: if request.resource.data.keys().hasOnly(['email_verified', 'updated_at']) && 
                       request.resource.data.email_verified == true;
      // Allow reading for password reset lookup (need to query by email)
      allow read: if true;
      // Allow password reset updates
      allow update: if request.resource.data.keys().hasAny(['password_reset_pending', 'password_reset_token', 'password_reset_requested_at', 'updated_at']);
    }
    
    // Profiles collection - allow own access and email verification  
    match /profiles/{profileId} {
      allow read, write: if request.auth != null && request.auth.uid == profileId;
      allow create: if request.auth != null && request.auth.uid == profileId;
      // Allow email verification updates (only email_verified field) from any authenticated user
      allow update: if request.resource.data.keys().hasOnly(['email_verified', 'updated_at']) && 
                       request.resource.data.email_verified == true;
    }
    
    // Family-based access control
    match /families/{familyId} {
      allow read, write: if request.auth != null && 
        (resource.data.parentIds.hasAny([request.auth.uid]) || 
         resource.data.studentIds.hasAny([request.auth.uid]));
      allow create: if request.auth != null;
      // Allow reading families for invite code lookup (needed for joining)
      allow read: if request.auth != null;
      // Allow students to join families (add themselves to studentIds array)
      allow update: if request.auth != null && 
        request.resource.data.studentIds.hasAny([request.auth.uid]) &&
        !resource.data.studentIds.hasAny([request.auth.uid]) &&
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['studentIds', 'updated_at']);
    }
    
    // Wellness entries - user can access their own, family members can read
    match /wellness_entries/{entryId} {
      allow read: if request.auth != null && 
        (resource.data.user_id == request.auth.uid || 
         isInSameFamily(request.auth.uid, resource.data.user_id));
      allow write: if request.auth != null && 
        request.auth.uid == resource.data.user_id;
      allow create: if request.auth != null && 
        request.auth.uid == request.resource.data.user_id &&
        validateWellnessEntry(request.resource.data);
    }
    
    // Validate wellness entry data
    function validateWellnessEntry(data) {
      return data.keys().hasAll(['user_id', 'mood', 'sleep_hours', 'exercise_minutes', 'nutrition', 'water', 'social', 'academic']) &&
             data.mood is number && data.mood >= 1 && data.mood <= 10 &&
             data.sleep_hours is number && data.sleep_hours >= 0 && data.sleep_hours <= 24 &&
             data.exercise_minutes is number && data.exercise_minutes >= 0 &&
             data.nutrition is number && data.nutrition >= 1 && data.nutrition <= 10 &&
             data.water is number && data.water >= 0 && data.water <= 20 &&
             data.social is number && data.social >= 1 && data.social <= 10 &&
             data.academic is number && data.academic >= 1 && data.academic <= 10;
    }
    
    // Rewards - user can access their own, family members can read
    match /rewards/{rewardId} {
      allow read: if request.auth != null && 
        (resource.data.user_id == request.auth.uid || 
         isInSameFamily(request.auth.uid, resource.data.user_id));
      allow write: if request.auth != null && 
        request.auth.uid == resource.data.user_id;
      allow create: if request.auth != null && 
        request.auth.uid == request.resource.data.user_id;
    }
    
    // Payments - strict validation and access control (requires email verification)
    match /payments/{paymentId} {
      allow read: if request.auth != null && 
        (resource.data.parent_id == request.auth.uid || 
         resource.data.student_id == request.auth.uid);
      allow create: if request.auth != null && 
        request.resource.data.parent_id == request.auth.uid &&
        validatePaymentData(request.resource.data) &&
        isEmailVerified(request.auth.uid);
      allow update: if request.auth != null && 
        resource.data.parent_id == request.auth.uid &&
        validatePaymentUpdate(resource.data, request.resource.data);
      allow delete: if false; // Never allow payment deletion
      
      // Validate payment creation data
      function validatePaymentData(data) {
        return data.keys().hasAll(['parent_id', 'student_id', 'intent_cents', 'provider', 'status']) &&
               data.intent_cents is int &&
               data.intent_cents > 0 &&
               data.intent_cents <= 10000000 && // Max $100,000
               data.provider in ['paypal', 'venmo', 'zelle'] &&
               data.status == 'initiated';
      }
      
      // Validate payment updates (only allow status and verification fields)
      function validatePaymentUpdate(oldData, newData) {
        let allowedFields = ['status', 'completed_at', 'updated_at', 'verification_method', 'provider_transaction_id', 'error_message', 'paypal_order_id', 'cancelled_at', 'cancelled_reason', 'completion_method', 'paypal_capture_id', 'paypal_capture_data', 'paypal_order_data', 'recipient_email'];
        return newData.diff(oldData).affectedKeys().hasOnly(allowedFields);
      }
    }

    // Subscriptions - parents can read/write their own
    match /subscriptions/{subscriptionId} {
      allow read, write: if request.auth != null && 
        resource.data.user_id == request.auth.uid;
      allow create: if request.auth != null && 
        request.resource.data.user_id == request.auth.uid;
    }

    // Monthly spend tracking - parents can read/write their own
    match /monthly_spend/{spendId} {
      allow read, write: if request.auth != null && 
        resource.data.parent_id == request.auth.uid;
      allow create: if request.auth != null && 
        request.resource.data.parent_id == request.auth.uid;
    }

    // Messages - users can read their own messages and write to family members (requires email verification)
    match /messages/{messageId} {
      allow read: if request.auth != null && 
        (resource.data.from_user_id == request.auth.uid || 
         resource.data.to_user_id == request.auth.uid);
      allow create: if request.auth != null && 
        request.resource.data.from_user_id == request.auth.uid &&
        isInSameFamily(request.auth.uid, request.resource.data.to_user_id) &&
        isEmailVerified(request.auth.uid);
      allow update: if request.auth != null && 
        resource.data.to_user_id == request.auth.uid;
    }

    // Support requests - students can create, family members can read
    match /support_requests/{requestId} {
      allow read: if request.auth != null && 
        (resource.data.from_user_id == request.auth.uid || 
         exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
         get(/databases/$(database)/documents/users/$(request.auth.uid)).data.family_id == resource.data.family_id);
      allow create: if request.auth != null && 
        request.resource.data.from_user_id == request.auth.uid;
      allow update: if request.auth != null && 
        (resource.data.from_user_id == request.auth.uid || 
         exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
         get(/databases/$(database)/documents/users/$(request.auth.uid)).data.family_id == resource.data.family_id);
    }

    // Transactions (PayPal P2P) - parents and students can read their own transactions (requires email verification for creation)
    match /transactions/{transactionId} {
      allow read: if request.auth != null && 
        (resource.data.parentId == request.auth.uid || 
         resource.data.studentId == request.auth.uid);
      allow create: if request.auth != null && 
        request.resource.data.parentId == request.auth.uid &&
        isInSameFamily(request.auth.uid, request.resource.data.studentId) &&
        isEmailVerified(request.auth.uid);
      allow update: if request.auth != null && 
        resource.data.parentId == request.auth.uid;
    }

    // User progress - users can read/write their own progress
    match /user_progress/{userId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
      allow create: if request.auth != null && request.auth.uid == userId;
    }

    // Item requests - students can create, parents can read/update (requires email verification for creation)
    match /item_requests/{requestId} {
      // Students can create item requests for themselves (requires email verification)
      allow create: if request.auth != null && 
        request.resource.data.student_id == request.auth.uid &&
        validateItemRequest(request.resource.data) &&
        isEmailVerified(request.auth.uid);
      
      // Parents can read item requests sent to them
      allow read: if request.auth != null && 
        resource.data.parent_id == request.auth.uid;
      
      // Students can read their own item requests  
      allow read: if request.auth != null && 
        resource.data.student_id == request.auth.uid;
      
      // Parents can update status of item requests sent to them
      allow update: if request.auth != null && 
        resource.data.parent_id == request.auth.uid &&
        validateItemRequestUpdate(resource.data, request.resource.data);

      // Validate item request creation data
      function validateItemRequest(data) {
        return data.keys().hasAll(['student_id', 'parent_id', 'item_name', 'reason', 'status']) &&
               data.item_name is string &&
               data.item_name.size() > 0 &&
               data.reason is string &&
               data.reason.size() > 0 &&
               data.status == 'pending' &&
               (!data.keys().hasAny(['item_price']) || data.item_price is int) &&
               (!data.keys().hasAny(['item_description']) || data.item_description is string);
      }
      
      // Validate item request updates (only allow status and related fields)
      function validateItemRequestUpdate(oldData, newData) {
        let allowedFields = ['status', 'updated_at', 'response_at', 'response_note', 'decline_reason', 'approve_reason'];
        return newData.diff(oldData).affectedKeys().hasOnly(allowedFields) &&
               newData.status in ['pending', 'approved', 'declined'];
      }
    }
  }
}